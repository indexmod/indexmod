<canvas id="c" width="300" height="300" style="
    display: block;
    background: transparent;
    vertical-align: bottom;
    align: left;
    border: none;
"></canvas>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from "three";
    import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
    import { mergeGeometries } from "three/addons/utils/BufferGeometryUtils.js";

    let scene, camera, renderer, mesh;

    function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(35, 1, 0.1, 20);
        camera.position.set(0, 0, 6.5);

        renderer = new THREE.WebGLRenderer({ canvas: document.getElementById("c"), antialias: true, alpha: true });
        renderer.setSize(300, 300);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 5, 5);
        scene.add(light);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        new RGBELoader().load(
          "https://cdn.polyhaven.org/hdri/indoor/indoor_01_4k.hdr",
            function (texture) {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;

                createObject();
                animate();
            }
        );
    }

    function createObject() {
        const material = new THREE.MeshStandardMaterial({
            roughness: 0,
            metalness: 1,
            envMapIntensity: 1.5
        });

        // Массив для геометрий
        const M = [];
        let p = new THREE.BoxGeometry(1, 1, 1, 1, 1, 1);
        M.push(p);

        let m = p.clone();
        m.rotateY(Math.PI / 4);
        m.rotateX(Math.PI / 4);
        M.push(m);

        m = p.clone();
        m.rotateZ(Math.PI / 4);
        m.rotateX(Math.PI / 4);
        M.push(m);

        p = mergeGeometries(M, false);

        // Создаем Mesh с объединенной геометрией и материалом
        mesh = new THREE.Mesh(p, material);
        scene.add(mesh);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (mesh) {
            mesh.rotation.y += 0.01;
        }

        renderer.render(scene, camera);
    }

    window.addEventListener("resize", () => {
        renderer.setSize(300, 300);
    });

    init();
</script>
